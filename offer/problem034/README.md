#最小的k个数#

*   使用快排的partition，类似于上一题，记得注意非法输入的情况，做好负面测试。
*   时间复杂度O(n)

*   还有一种特别适合海量数据存储的方法，顺序遍历所有数据，并创建一个大小为k的容器来存储最小的k个数。
*   当容器满的时候，我们要做3件事
    -   一是在k个整数中找到最大数
    -   二是有可能在这个容器中删除最大数
    -   三是有可能要插入一个新的数字
*   总的时间复杂度是O(nlogk)
*   最大堆（priority_queue是基于最大堆实现的）是很符合此题条件的容器，还有红黑树（set和multiset都是基于红黑树实现的）。
*   priority_queue可以自己实现compare。
