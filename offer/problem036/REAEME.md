#连续子数组的最大值#

*   动态规划解法：f(i)表示以第i个数字结尾的子数组的最大和，那么我们只需求出max[f(i)]
*   如果i = 0或f(i-1) <= 0，f(i) = array[i]
*   如果i != 0并且f(i-1) > 0，f(i) = f(i-1) + array[i]

*   考虑数组的特点：当前子数组的和为负时，抛弃，重新开始，全程记录当前最大的子数组和。
