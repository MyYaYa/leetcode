#背包问题#

##0-1背包问题##
*   每个物品只有一个。
*   找到递推式。求解问题F(W, n)，W代表最大重量，n代表当前物品个数。
*   当n的重量大于W时，等于F(W, n-1)；否则，等于max{val[n]+F(W-w[n], n-1), F(W, n-1)}。
*   动态规划时，如果使用二维数组，在物品或者背包容量较大时会在空间复杂度上比较高。
*   所以使用滚动数组，如果简单的替换为一维数组，则会重复更新滚动数组的值，会产生错误。
*   所以从W开始向下循环更新，不会出现上述问题，但是循环终止条件为W>当前物品的重量。

##完全背包问题##
*   每个物品可能有0个，也可能有无数个。
*   递推公式 dp[i][j] = max(dp[i-1][j], k*vals[i]+dp[i-1][j-k*w[i]])，其中0 <= k <= j/w[i]。
*   存在一种直观的优化方法，把物品扩展，每个物品能在背包容量下放几个就扩展成几个，转变成01背包问题。同时在扩展时，也可采用二进制的表示方法，把最多放的个数k用二进制表示，降低时间复杂度为O(W∑log(k))。
*   同样，二维数组存在空间复杂度较高的问题，所以使用滚动数组来实现，详细见代码，其很像01背包问题，就是循环变成正序，而不是01背包问题中的倒序。此时时间复杂度为O(NW)。

##01背包与完全背包关于滚动数组形式代码的解释##
*   在01背包中，j的变化区间为倒序的原因时，由dp[i-1][j-w[i]]递推状态dp[i][j]时，dp[i-1][j-w[i]]中没有放入第i件物品。之后，在第i循环时，放入一件第i件物品。
*   01背包的方程：f[i][v] = max(f[i - 1][v],f[i - 1][v - weight[i]] + Value[i])


*   在完全背包中，j的变化区间是顺序循环的原因是：完全背包问题的特点是每种物品可选无限件，在求解加选第i种物品带来的收益dp[i][j]时，在状态dp[i][j-w[i]]中已经尽可能放入物品i了，此时在dp[i][j-w[i]]的基础上，在放入一个物品i，此时也是在不超过背包容量的基础下，尽可能多的放入物品i。
*   完全背包的方程：f[i][v] = max(f[i - 1][v],f[i][v - weight[i]] + Value[i])


##多重背包##
*   多重背包其实就是01背包和完全背包的混合问题。
*   可以使用转化为0-1背包问题的解法，但是时间复杂度较高。
*   也可以使用0-1问题和完全背包问题的混合解法。同时在此解法中，把某种类物品的个数k用二进制表示，把完全背包问题的复杂度降低为O(W∑log(k))。
